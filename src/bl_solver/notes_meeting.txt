def condition_1(
    f, g, h,
    theta, gamma, eta, 
    p, q, s, s_succ
    ):
    pass

def one_shot():
    theta = ...
    gamma = ...
    eta   = ...

    s     = IntVal
    s_succ= IntVal

    phis = encode_classification(...)

    formula = Forall([*s, *s_succ],
        And(phis)
    )
    
# m = controesempi
def guess(m):
    theta = ...
    gamma = ...
    eta   = ...

    phis = []

    for (s, s_succ) in m:
        phis.append(*encode_classification(theta, gamma, eta, s, s_succ))
            
    solver = Solver()
    for phi in phis:
        solver.add(phi)

    assert solver.check() == "sat"
    # if not sat we have to change templates
    # for now, we assume satisfiable

    m = solver.model()
    return m[theta], m[gamma], m[eta]

def encode_classification(theta, gamma, eta, s, s_succ):
    phis = []
    for p in ..:
        for q in ..:
            
            phis.append(condition_1(theta, gamma, eta, p, q, s, s_succ))
            phis.append(condition_2(theta, gamma, eta, p, q, s, s_succ))

    return phis

def check(theta, gamma, eta):
    s = IntVal...
    s_succ = IntVal...

    cexs = []
    phis = encode_classification(theta, gamma, eta, s, s_succ)
    for phi in phis:
        # nota: parallelizzabile
        solver = Solver()
        solver.add(Not(phi))
        solver.check()
        if satisfied:
            m = solver.model()
            cex.append((m[s], m[s_succ]))

             
    return cexs

def bisimulation_learning(successor):
    while True:
        template = propose_template()
        guess_and_check(template)


def guess_and_check(template):
    cexs = []
    while True:
        res = guess(cexs)
        if let theta, gamma, eta = Some(res):
            new_cexs = check(f, g, h, theta, gamma, eta)
            if len(new_cexs) == 0:
                return
            else:
                cexs.append(...new_cexs)
        else:


